### Unary/Binary/Ternary Operator的定義

**1. Unary Operator（单目运算符）**
- 定义：只作用于一个操作数的运算符。
- 常见运算符：
  - 正号 `+` 和负号 `-`
  - 按位取反 `~`
  - 布尔取反 `not`

> 這裏需要解釋一些上面中的按位按位取反：在 Python 中，按位取反运算符 `~` 会对一个整数的所有比特位进行取反（将 `0` 变成 `1`，将 `1` 变成 `0`），并根据补码的存储规则计算结果。Python 使用补码表示有符号整数，对于任意整数 $n$，表达式 `~n` 等价于公式 $-(n+1)$，即将数字加一后取相反数。从二进制角度来看（假设32位系统），正数直接用普通二进制表示，而负数使用补码形式存储。对于数字 5，其二进制表示为 `0000...0101`（省略高位的零）；按位取反后得到二进制值为 `1111...1010`（对应十进制补码形式的 -6）。结合步骤可以验证：先通过按位取反得到 ~5 的值为 -6。

```python
a = 5
print(-a,+a,~a,not True)   # 单目负号，结果为 -5
```

**2. Binary Operator（双目运算符）**

- 定义：作用于两个操作数之间的运算符。
- 常见运算符分类：
    - 算术运算(Arithmetic Operators)：`+`, `-`, `*`, `/`, `%`, `//`, `**`
    - 比较运算(Relational Operators)：`<`, `>`, `<=`, `>=`, `==`, `!=`
    - 位运算(Bitwise Operators)：`&`, `|`, `^`, `<<`, `>>`
    - 赋值操作(Assignment Operators)：`=, +=, -=, *=, /=, //=, **=`
    - 布尔逻辑(Logical Operators)：`and`, `or`
    - 成員運算符(Membership Operators)：`in`, `not in`
    - 身份運算符(Identity Operators)：`is`, `is not`

**3. Ternary Operator（三目运算符）**

- 定义：同时作用于三个操作数，用于条件表达式。
- 在Python中使用 **三元表达式 (Ternary Expression)** 的语法如下：
  
$$\text{value\_if\_true if condition else value\_if\_false}$$

```python
a = 5
result = "Positive" if a > 0 else "Non-positive"
print(result)
```

#### 算术运算(Arithmetic Operators)

| 运算符   | 名称           | 描述                                                                 |
|----------|----------------|----------------------------------------------------------------------|
| `+`      | 加法           | 对两个操作数进行加法运算，例如 `a + b`。                             |
| `-`      | 减法           | 对两个操作数进行减法运算，例如 `a - b`。                             |
| `*`      | 乘法           | 对两个操作数进行乘法运算，例如 `a * b`。                             |
| `/`      | 除法           | 对两个操作数进行除法，结果为浮点数，例如 `a / b`。                   |
| `%`      | 取模（余数）    | 返回除法的余数，例如 `a % b`（5 % 2 = 1）。                          |
| `//`     | 整除（地板除）  | 返回商的整数部分，向下取整，例如 `a // b`（7 // 2 = 3）。            |
| `**`     | 幂运算         | 返回左操作数的右操作数次幂，例如 `a ** b`（2 ** 3 = 8）。            |

#### 比较运算(Relational Operators)

| 运算符   | 名称              | 描述                                                                          |
|----------|-------------------|-------------------------------------------------------------------------------|
| `<`      | 小于              | 如果左操作数小于右操作数，则返回 `True`，否则返回 `False`。                   |
| `>`      | 大于              | 如果左操作数大于右操作数，则返回 `True`，否则返回 `False`。                   |
| `<=`     | 小于等于          | 如果左操作数小于或等于右操作数，则返回 `True`，否则返回 `False`。             |
| `>=`     | 大于等于          | 如果左操作数大于或等于右操作数，则返回 `True`，否则返回 `False`。             |
| `==`     | 等于              | 如果两个操作数相等，则返回 `True`，否则返回 `False`。                         |
| `!=`     | 不等于            | 如果两个操作数不相等，则返回 `True`，否则返回 `False`。                       |

#### 位运算(Bitwise Operators)

| 运算符   | 名称              | 描述                                                                                       |
|----------|-------------------|--------------------------------------------------------------------------------------------|
| `&`      | 按位与 (AND)      | 对应位置都为 `1` 时结果为 `1`，否则为 `0`。                                                |
| `\|`      | 按位或 (OR)       | 对应位置只要有一个为 `1` 时结果为 `1`，否则为 `0`。                                         |
| `^`      | 按位异或 (XOR)    | 对应位置不同则结果为 `1`，相同则为 `0`。                                                   |
| `~`      | 按位取反 (NOT)    | 将每个位取反：原本是 `1` 变成 `0`，原本是 `0` 变成 `1`；在补码表示下等价于 $-(x + 1)$。     |
| `<<`     | 左移 (Left Shift) | 将左操作数的所有位向左移动指定数量的位置，用零填充右边空出的部分，相当于乘以 $2^n$。       |
| `>>`     | 右移 (Right Shift)| 将左操作数的所有位向右移动指定数量的位置，用符号位填充（正数补零，负数补符号），相当于除以 $2^n$ 向下取整。|

```python
# 定义两个整数
a = 6        # 二进制: 00000110
b = 3        # 二进制: 00000011
# 位運算相當於二進制下的運算

# 位运算示例
print(f"按位与: {a} & {b} = {a & b} （二进制: {bin(a & b)}）")
print(f"按位或: {a} | {b} = {a | b} （二进制: {bin(a | b)}）")
print(f"按位异或: {a} ^ {b} = {a ^ b} （二进制: {bin(a ^ b)}）")
print(f"按位取反: ~{a} = {~a} （二进制: {bin(~a)}）")
print(f"左移两次: {a} << 2 = {a << 2} （二进制: {bin(a << 2)}）")
print(f"右移两次: {b} >> 2 = {b >> 2} （二进制: {bin(b >> 2)}）")

# 輸出爲什麼會包括0b呢？
# 如果您提到的是为什么二进制输出会包括 b 字符，那是因为 Python 的 bin() 函数 返回的是一个字符串，其中二进制格式以 '0b' 前缀标识。这种设计用于明确区分“普通数字”与“二进制表示”。
```

#### 赋值操作(Assignment Operators)

| 运算符 | 描述                                       | 例子      |
| ------ | ------------------------------------------ | --------- |
| =      | 将右侧的值赋给左侧变量                       | x = 5     |
| +=     | 将右侧的值加到左侧变量，并将结果赋给左侧变量 | x += 3    |
| -=     | 将右侧的值从左侧变量减去，并将结果赋给左侧变量 | x -= 2    |
| *=     | 将左侧变量乘以右侧的值，并将结果赋给左侧变量 | x *= 4    |
| /=     | 将左侧变量除以右侧的值，并将结果赋给左侧变量 | x /= 2    |
| %=     | 将左侧变量对右侧的值取模，并将结果赋给左侧变量 | x %= 3    |
| **=    | 将左侧变量的右侧值次幂，并将结果赋给左侧变量 | x **= 2   |
| //=    | 将左侧变量整除右侧的值，并将结果赋给左侧变量 | x //= 2   |
| &=     | 将左侧变量与右侧的值按位与，并将结果赋给左侧变量 | x &= 5    |
| \|=    | 将左侧变量与右侧的值按位或，并将结果赋给左侧变量 | x \|= 3   |
| ^=     | 将左侧变量与右侧的值按位异或，并将结果赋给左侧变量 | x ^= 7    |
| >>=    | 将左侧变量右移右侧的值指定的位数，并将结果赋给左侧变量 | x >>= 1   |
| <<=    | 将左侧变量左移右侧的值指定的位数，并将结果赋给左侧变量 | x <<= 1   |

#### 布尔逻辑运算符、成员运算符 和 身份运算符

| 运算符      | 分类               | 名称              | 描述                                                                 | 示例                     |
|-------------|--------------------|-------------------|----------------------------------------------------------------------|--------------------------|
| `and`       | 布尔逻辑运算符     | 逻辑与            | 如果两个条件都为真，则结果为真。                                     | `True and True` (结果为 `True`) |
| `or`        | 布尔逻辑运算符     | 逻辑或            | 如果至少有一个条件为真，则结果为真。                                 | `True or False` (结果为 `True`) |
| `not`       | 布尔逻辑运算符     | 逻辑非            | 对单一条件取反，如果为真则返回假，反之亦然。                         | `not True` (结果为 `False`) |
| `in`        | 成员运算符         | 成员检查          | 如果某个值在序列中，则返回 `True`；否则返回 `False`。                | `5 in [1, 2, 3, 4, 5]` (结果为 `True`) |
| `not in`    | 成员运算符         | 非成员检查        | 如果某个值不在序列中，则返回 `True`；否则返回 `False`。              | `6 not in [1, 2, 3, 4, 5]` (结果为 `True`) |
| `is`        | 身份运算符         | 身份相等          | 如果两个变量引用的是同一个对象，则返回 `True`; 否则返回 `False`。    | `x = 5; y = x; x is y` (结果为 `True`) |
| `is not`    | 身份运算符         | 身份不相等        | 如果两个变量引用的不是同一个对象，则返回 `True`; 否则返回 `False`。  | `x = 5; y = 6; x is not y` (结果为 `True`) |

### 運算符優先級

| 运算符                                      | 优先级 | Associativity |
| ------------------------------------------- | ------ | ------------- |
| `()` `[]` `{}` `.` (函数调用，属性引用等)    | 最高   | Left-to-right |
| `await` `**` (幂运算)                        |        | Right-to-left |
| `+x` `-x` `~x` (Unary运算符)                  |        | Right-to-left |
| `*` `/` `//` `%` (乘法，除法，整除，取模)     |        | Left-to-right |
| `+` `-` (加法，减法)                         |        | Left-to-right |
| `<<` `>>` (位移)                             |        | Left-to-right |
| `&` (按位与)                                 |        | Left-to-right |
| `^` (按位异或)                               |        | Left-to-right |
| `\|` (按位或)                                |        | Left-to-right |
| `==` `!=` `>` `>=` `<` `<=` `is` `is not` `in` `not in` (比较运算符，身份运算符，成员运算符) |        | Left-to-right |
| `not` (逻辑非)                               |        | Right-to-left |
| `and` (逻辑与)                               |        | Left-to-right |
| `or` (逻辑或)                                |        | Left-to-right |
| `if`-`else` (条件表达式)                     | 最低   | Right-to-left |

**Associativity（结合性）解释:**

结合性决定了当一个表达式中有多个相同优先级的运算符时，运算的顺序。

* **Left-to-right (从左到右):**  表达式从左向右计算。例如，`a - b + c` 会被计算为 `(a - b) + c`。
* **Right-to-left (从右到左):** 表达式从右向左计算。例如，`a ** b ** c` 会被计算为 `a ** (b ** c)`。

### 字符串下的運算

| 运算符类型       | 运算符   | 描述                                       | 示例 (`s1 = "Hello"`, `s2 = "World"`)          | 结果                |
|--------------------|----------|--------------------------------------------|-----------------------------------------------|---------------------|
| 算术运算(拼接)     | `+`      | 字符串拼接                                 | `s1 + s2`                                     | `"HelloWorld"`      |
| 算术运算(重复)     | `*`      | 字符串重复                                 | `s1 * 3`                                      | `"HelloHelloHello"` |
| 比较运算(小于)     | `<`      | 字典序小于比较                             | `s1 < s2`                                     | `True`              |
| 比较运算(大于)     | `>`      | 字典序大于比较                             | `s1 > s2`                                     | `False`             |
| 比较运算(小于等于) | `<=`     | 字典序小于等于比较                         | `s1 <= "Hello"`                               | `True`              |
| 比较运算(大于等于) | `>=`     | 字典序大于等于比较                         | `s1 >= "Hell"`                                | `True`              |
| 比较运算(等于)     | `==`     | 字符串内容相等比较                         | `s1 == "Hello"`                               | `True`              |
| 比较运算(不等于)   | `!=`     | 字符串内容不相等比较                       | `s1 != s2`                                     | `True`              |
| 赋值操作           | `=`      | 赋值                                       | `s3 = s1`                                     | `s3` 值为 `"Hello"` |
| 赋值操作(拼接)     | `+=`     | 拼接并赋值                                 | `s1 += s2`                                    | `s1` 值为 `"HelloWorld"` |
| 布尔逻辑(与)       | `and`    | 逻辑与 (空字符串视为 `False`)              | `s1 and s2`                                   | `"World"`           |
| 布尔逻辑(或)       | `or`     | 逻辑或 (空字符串视为 `False`)              | `s1 or s2`                                    | `"Hello"`           |
| 成员运算(存在)     | `in`     | 判断子字符串是否存在                       | `"o" in s2`                                   | `True`              |
| 成员运算(不存在)   | `not in` | 判断子字符串是否不存在                     | `"z" not in s2`                               | `True`              |
| 身份运算(相同)     | `is`     | 判断两个变量是否指向同一对象（内存地址）   | `s1 is "Hello"` (取决于字符串是否被复用)      | `True` 或 `False`   |
| 身份运算(不同)     | `is not` | 判断两个变量是否指向不同对象（内存地址）   | `s1 is not s2`                               | `True`              |

> 字典序（Lexicographical Order），也称词典序或字母序，是一种基于字符顺序排列字符串的方法。比较字符串字典序时，从首字符开始逐个比较字符的ASCII或Unicode码点值，码点值小的字符所在字符串靠前；若字符相同则继续比较后续字符，直至找到不同字符或某字符串结束；若一字符串是另一字符串的前缀，则较短的字符串靠前。例如，"apple"小于"banana"因为'a'的码点值小于'b'，"app"小于"apple"因为"app"是"apple"的前缀，"cat"大于"car"因为't'的码点值大于'r'。


#### 

